name: Frontend CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'frontend/**'
      - 'scripts/build-frontend.sh'
      - 'scripts/deploy-frontend.sh'
      - 'scripts/pipeline-frontend.sh'
      - 'scripts/manage-environment.sh'
      - '.github/workflows/frontend-ci-cd.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'frontend/**'
      - 'scripts/build-frontend.sh'
      - 'scripts/deploy-frontend.sh'
      - 'scripts/pipeline-frontend.sh'
      - 'scripts/manage-environment.sh'
      - '.github/workflows/frontend-ci-cd.yml'

env:
  NODE_VERSION: '22.x'
  AWS_REGION: 'ap-northeast-1'

jobs:
  # Test and Build Job
  test-and-build:
    name: Test and Build Frontend
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json
        
    - name: Install dependencies
      run: |
        cd frontend
        npm ci
        
    - name: Run linting
      run: |
        cd frontend
        npm run lint
        
    - name: Run type checking
      run: |
        cd frontend
        npm run type-check
        
    - name: Run unit tests
      run: |
        cd frontend
        npm run test:run
        
    - name: Run test coverage
      run: |
        cd frontend
        npm run test:coverage
        
    - name: Upload coverage reports
      uses: codecov/codecov-action@v4
      with:
        directory: frontend/coverage
        flags: frontend
        name: frontend-coverage
        fail_ci_if_error: false
        
    - name: Build application
      run: |
        chmod +x scripts/build-frontend.sh
        ./scripts/build-frontend.sh -e production
        
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: frontend-build-${{ github.sha }}
        path: frontend/dist/
        retention-days: 30

  # End-to-End Tests Job
  e2e-tests:
    name: End-to-End Tests
    runs-on: ubuntu-latest
    needs: test-and-build
    if: github.event_name == 'pull_request' || github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json
        
    - name: Install dependencies
      run: |
        cd frontend
        npm ci
        
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: frontend-build-${{ github.sha }}
        path: frontend/dist/
        
    - name: Run Cypress E2E tests
      uses: cypress-io/github-action@v6
      with:
        working-directory: frontend
        start: npm run preview
        wait-on: 'http://localhost:4173'
        wait-on-timeout: 120
        browser: chrome
        record: false
        
    - name: Upload Cypress screenshots
      uses: actions/upload-artifact@v4
      if: failure()
      with:
        name: cypress-screenshots-${{ github.sha }}
        path: frontend/cypress/screenshots/
        retention-days: 7
        
    - name: Upload Cypress videos
      uses: actions/upload-artifact@v4
      if: failure()
      with:
        name: cypress-videos-${{ github.sha }}
        path: frontend/cypress/videos/
        retention-days: 7

  # Security Scan Job
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: test-and-build
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json
        
    - name: Install dependencies
      run: |
        cd frontend
        npm ci
        
    - name: Run npm audit
      run: |
        cd frontend
        npm audit --audit-level=high
        
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: frontend-build-${{ github.sha }}
        path: frontend/dist/
        
    - name: Scan build for secrets
      run: |
        # Check for potential secrets in build files
        if grep -r "API_KEY_VALUE\|aws_secret_access_key\|AKIA[0-9A-Z]{16}" frontend/dist/ --exclude="*.map" 2>/dev/null; then
          echo "❌ Found potential secrets in build files"
          exit 1
        else
          echo "✅ No secrets found in build files"
        fi

  # Deploy to Staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [test-and-build, security-scan]
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    environment: staging
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: frontend-build-${{ github.sha }}
        path: frontend/dist/
        
    - name: Deploy to staging
      run: |
        chmod +x scripts/deploy-frontend.sh
        ./scripts/deploy-frontend.sh -e staging --wait-invalidation
        
    - name: Run deployment health check
      run: |
        # Get CloudFront URL from stack outputs
        CLOUDFRONT_URL=$(aws cloudformation describe-stacks \
          --stack-name "FrontendStack-Staging" \
          --query 'Stacks[0].Outputs[?OutputKey==`FrontendCloudFrontDistributionUrl`].OutputValue' \
          --output text 2>/dev/null || echo "")
        
        if [ -n "$CLOUDFRONT_URL" ] && [ "$CLOUDFRONT_URL" != "None" ]; then
          echo "Testing deployment at: $CLOUDFRONT_URL"
          
          # Wait for deployment to propagate
          sleep 30
          
          # Test main page
          if curl -f -s "$CLOUDFRONT_URL" > /dev/null; then
            echo "✅ Staging deployment is accessible"
          else
            echo "❌ Staging deployment is not accessible"
            exit 1
          fi
          
          # Test health endpoint
          if curl -f -s "$CLOUDFRONT_URL/health" > /dev/null; then
            echo "✅ Health API endpoint is accessible"
          else
            echo "⚠️ Health API endpoint may not be immediately accessible"
          fi
        else
          echo "⚠️ Could not retrieve CloudFront URL for health check"
        fi

  # Deploy to Production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [test-and-build, e2e-tests, security-scan]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: frontend-build-${{ github.sha }}
        path: frontend/dist/
        
    - name: Deploy to production
      run: |
        chmod +x scripts/deploy-frontend.sh
        ./scripts/deploy-frontend.sh -e production --wait-invalidation
        
    - name: Run deployment health check
      run: |
        # Get CloudFront URL from stack outputs
        CLOUDFRONT_URL=$(aws cloudformation describe-stacks \
          --stack-name "FrontendStack" \
          --query 'Stacks[0].Outputs[?OutputKey==`FrontendCloudFrontDistributionUrl`].OutputValue' \
          --output text 2>/dev/null || echo "")
        
        if [ -n "$CLOUDFRONT_URL" ] && [ "$CLOUDFRONT_URL" != "None" ]; then
          echo "Testing deployment at: $CLOUDFRONT_URL"
          
          # Wait for deployment to propagate
          sleep 30
          
          # Test main page
          if curl -f -s "$CLOUDFRONT_URL" > /dev/null; then
            echo "✅ Production deployment is accessible"
          else
            echo "❌ Production deployment is not accessible"
            exit 1
          fi
          
          # Test health endpoint
          if curl -f -s "$CLOUDFRONT_URL/health" > /dev/null; then
            echo "✅ Health API endpoint is accessible"
          else
            echo "⚠️ Health API endpoint may not be immediately accessible"
          fi
          
          # Test analytics endpoint routing
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$CLOUDFRONT_URL/analytics/query" || echo "000")
          if [ "$HTTP_STATUS" = "400" ] || [ "$HTTP_STATUS" = "401" ] || [ "$HTTP_STATUS" = "200" ]; then
            echo "✅ Analytics API endpoint is routed correctly (HTTP $HTTP_STATUS)"
          else
            echo "⚠️ Analytics API endpoint routing may have issues (HTTP $HTTP_STATUS)"
          fi
        else
          echo "⚠️ Could not retrieve CloudFront URL for health check"
        fi
        
    - name: Create deployment tag
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        TAG_NAME="frontend-v$(date +'%Y%m%d-%H%M%S')"
        git tag -a "$TAG_NAME" -m "Frontend deployment $TAG_NAME"
        git push origin "$TAG_NAME"

  # Rollback Job (Manual trigger)
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Rollback deployment
      run: |
        echo "⚠️ Manual rollback procedure:"
        echo "1. Check recent deployments in S3 bucket backups"
        echo "2. Use AWS Console to restore previous version"
        echo "3. Invalidate CloudFront cache"
        echo "4. Run health checks"
        echo ""
        echo "For automated rollback, implement version management in deployment scripts"

# Workflow dispatch for manual triggers
on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      skip_tests:
        description: 'Skip tests (emergency deployment)'
        required: false
        default: false
        type: boolean